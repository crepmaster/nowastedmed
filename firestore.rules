rules_version = '2';

/**
 * Firestore Security Rules for NoWastedMed (MediExchange)
 *
 * These rules enforce access control for the medicine exchange platform.
 *
 * Collections:
 * - pharmacies: Pharmacist user profiles
 * - couriers: Courier user profiles
 * - admins: Admin user profiles
 * - exchanges: Medicine exchange requests
 * - exchange_proposals: Counter-proposals for exchanges
 * - pharmacy_inventory: Medicine inventory
 * - deliveries: Delivery assignments with payment tracking
 *
 * STATE MACHINES:
 * - Exchange: draft → pending → accepted → in_transit → completed
 *                              → rejected
 * - Delivery: pending → assigned → picked_up → in_transit → delivered
 *                     → cancelled                        → failed
 * - DeliveryPayment: awaiting_payment → partial_payment → payment_complete → released_to_courier
 *                                                       → refunded
 *
 * DEPLOYMENT:
 * firebase deploy --only firestore:rules
 *
 * TESTING:
 * Use Firebase Emulator Suite for local testing
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // ============================================

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if the user is accessing their own document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Get user's role from their profile
    function getUserRole() {
      let pharmacyDoc = get(/databases/$(database)/documents/pharmacies/$(request.auth.uid));
      let courierDoc = get(/databases/$(database)/documents/couriers/$(request.auth.uid));
      let adminDoc = get(/databases/$(database)/documents/admins/$(request.auth.uid));

      return pharmacyDoc.data != null ? 'pharmacist' :
             courierDoc.data != null ? 'courier' :
             adminDoc.data != null ? 'admin' : null;
    }

    // Check if user is a pharmacist
    function isPharmacist() {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/pharmacies/$(request.auth.uid));
    }

    // Check if user is a courier
    function isCourier() {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/couriers/$(request.auth.uid));
    }

    // Check if user is an admin
    function isAdmin() {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    // Validate string field length
    function validString(field, minLen, maxLen) {
      return field is string && field.size() >= minLen && field.size() <= maxLen;
    }

    // Validate required string field
    function validRequiredString(field) {
      return field is string && field.size() > 0;
    }

    // Check if courier operates in a specific city
    // FIXED: Now reads from couriers collection instead of users
    function courierOperatesInCity(cityId) {
      let courierDoc = get(/databases/$(database)/documents/couriers/$(request.auth.uid));
      return courierDoc != null &&
             courierDoc.data.operatingCities != null &&
             cityId in courierDoc.data.operatingCities;
    }

    // Get pharmacy's city for exchange filtering
    function getPharmacyCityId() {
      let pharmacyDoc = get(/databases/$(database)/documents/pharmacies/$(request.auth.uid));
      return pharmacyDoc != null && pharmacyDoc.data.location != null
             ? pharmacyDoc.data.location.cityId
             : null;
    }

    // ============================================
    // EXCHANGE STATUS TRANSITION HELPERS
    // ============================================

    // Valid exchange status transitions
    // draft → pending (requester publishes)
    // pending → pending (responder submits proposal, sets proposedTo)
    // pending → accepted (requester accepts proposal) | rejected (requester rejects proposal)
    // accepted → in_transit (courier picks up)
    // in_transit → completed (courier delivers)
    // rejected → pending (requester can re-open for new responders)
    function isValidExchangeTransition(fromStatus, toStatus) {
      return (fromStatus == 'draft' && toStatus == 'pending') ||
             (fromStatus == 'pending' && toStatus in ['accepted', 'rejected']) ||
             (fromStatus == 'accepted' && toStatus == 'in_transit') ||
             (fromStatus == 'in_transit' && toStatus == 'completed') ||
             (fromStatus == 'rejected' && toStatus == 'pending');
    }

    // Check if user is the exchange requester (proposedBy)
    function isExchangeRequester(exchangeData) {
      return request.auth.uid == exchangeData.proposedBy;
    }

    // Check if user is the exchange responder (proposedTo)
    function isExchangeResponder(exchangeData) {
      return request.auth.uid == exchangeData.proposedTo;
    }

    // Check if user is involved in the exchange
    function isExchangeParticipant(exchangeData) {
      return isExchangeRequester(exchangeData) || isExchangeResponder(exchangeData);
    }

    // Immutable fields that should NEVER change after creation
    // Used to ensure location.cityId and proposedBy are locked
    function exchangeImmutableFieldsUnchanged() {
      return request.resource.data.proposedBy == resource.data.proposedBy &&
             request.resource.data.location.cityId == resource.data.location.cityId &&
             request.resource.data.location.countryCode == resource.data.location.countryCode;
    }

    // ============================================
    // DELIVERY STATUS TRANSITION HELPERS
    // ============================================

    // Valid delivery status transitions
    // pending → assigned (courier accepts)
    // assigned → picked_up (courier at pickup)
    // picked_up → in_transit (courier has package)
    // in_transit → delivered (courier completes) | failed (delivery failed)
    // pending → cancelled (pharmacy cancels before assignment)
    // assigned → cancelled (pharmacy cancels, courier not yet picked up)
    function isValidDeliveryTransition(fromStatus, toStatus) {
      return (fromStatus == 'pending' && toStatus in ['assigned', 'cancelled']) ||
             (fromStatus == 'assigned' && toStatus in ['picked_up', 'cancelled']) ||
             (fromStatus == 'picked_up' && toStatus == 'in_transit') ||
             (fromStatus == 'in_transit' && toStatus in ['delivered', 'failed']);
    }

    // Check if delivery payment is complete (both pharmacies paid)
    function isDeliveryPaymentComplete(deliveryData) {
      return deliveryData.paymentStatus == 'payment_complete';
    }

    // ============================================
    // USER PROFILE COLLECTIONS
    // ============================================

    // Pharmacies collection
    match /pharmacies/{userId} {
      // Users can read their own profile
      // Admins can read all profiles
      // Other pharmacists can read basic info for exchange purposes
      allow read: if isOwner(userId) || isAdmin() || isPharmacist();

      // Only the user can update their own profile (except isActive which admin controls)
      allow update: if isOwner(userId) &&
                       !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'createdAt']);

      // Users can create their own profile during registration (document ID must match auth UID)
      // Admins can also create profiles
      allow create: if isAdmin() ||
                       (isAuthenticated() && request.auth.uid == userId &&
                        request.resource.data.role == 'pharmacist' &&
                        validRequiredString(request.resource.data.email));

      // Only admins can delete profiles
      allow delete: if isAdmin();
    }

    // Couriers collection
    match /couriers/{userId} {
      // Users can read their own profile
      // Admins can read all profiles
      // Pharmacists can read courier info for delivery tracking
      allow read: if isOwner(userId) || isAdmin() || isPharmacist();

      // Only the user can update their own profile
      allow update: if isOwner(userId) &&
                       !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'createdAt']);

      // Users can create their own profile during registration (document ID must match auth UID)
      // Admins can also create profiles
      allow create: if isAdmin() ||
                       (isAuthenticated() && request.auth.uid == userId &&
                        request.resource.data.role == 'courier' &&
                        validRequiredString(request.resource.data.email));

      // Only admins can delete profiles
      allow delete: if isAdmin();
    }

    // Admins collection
    match /admins/{userId} {
      // Only the admin can read their own profile
      // Other admins can read for verification
      allow read: if isOwner(userId) || isAdmin();

      // Only the user can update their own profile
      allow update: if isOwner(userId) &&
                       !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'createdAt']);

      // Only existing admins can create new admins
      allow create: if isAdmin();

      // Only admins can delete admin profiles
      allow delete: if isAdmin();
    }

    // ============================================
    // PHARMACY INVENTORY
    // ============================================

    match /pharmacy_inventory/{medicineId} {
      // Pharmacies can read their own inventory
      // Other pharmacies can read medicines available for exchange
      // Admins can read all for statistics
      allow read: if isAuthenticated() && (
                     resource.data.pharmacyId == request.auth.uid ||
                     resource.data.availableForExchange == true ||
                     isAdmin()
                   );

      // Pharmacy can only create medicines for their own inventory
      allow create: if isPharmacist() &&
                       request.resource.data.pharmacyId == request.auth.uid &&
                       validRequiredString(request.resource.data.name) &&
                       request.resource.data.quantity >= 0;

      // Pharmacy can only update their own medicines
      allow update: if isPharmacist() &&
                       resource.data.pharmacyId == request.auth.uid &&
                       request.resource.data.pharmacyId == request.auth.uid &&
                       request.resource.data.quantity >= 0;

      // Pharmacy can only delete their own medicines
      allow delete: if isPharmacist() &&
                       resource.data.pharmacyId == request.auth.uid;
    }

    // ============================================
    // EXCHANGES
    // ============================================

    match /exchanges/{exchangeId} {
      // READ RULES:
      // - Participants (requester/responder) can always read their exchanges
      // - Couriers can read exchanges they are assigned to deliver
      // - Pharmacists in the same city can read pending exchanges (for browsing)
      // - Admins can read all
      allow read: if isAuthenticated() && (
                     // Participants can always read
                     isExchangeParticipant(resource.data) ||
                     // Assigned courier can read
                     resource.data.courierId == request.auth.uid ||
                     // Same-city pharmacists can browse pending exchanges
                     (isPharmacist() &&
                      resource.data.status == 'pending' &&
                      resource.data.location != null &&
                      resource.data.location.cityId == getPharmacyCityId()) ||
                     // Admin can read all
                     isAdmin()
                   );

      // CREATE RULES:
      // - Only pharmacists can create exchanges
      // - Must be the requester (proposedBy)
      // - Must start in draft or pending status
      // - Must include location data for city filtering
      // - proposedTo can be empty for broadcast exchanges (any pharmacy in city can respond)
      //   or set to a specific pharmacy ID for direct exchanges
      allow create: if isPharmacist() &&
                       request.resource.data.proposedBy == request.auth.uid &&
                       request.resource.data.status in ['draft', 'pending'] &&
                       request.resource.data.location != null &&
                       validRequiredString(request.resource.data.location.cityId) &&
                       // proposedTo is optional (null/empty for broadcast, specific ID for direct)
                       (request.resource.data.proposedTo == null ||
                        request.resource.data.proposedTo == '' ||
                        request.resource.data.proposedTo is string);

      // UPDATE RULES with strict state machine and field-level enforcement:
      // ALL updates must preserve immutable fields (proposedBy, location.cityId, location.countryCode)
      allow update: if isAuthenticated() && (
                       // REQUESTER can:
                       // - Update draft exchanges (add medicines, set details)
                       // - Transition: draft → pending (publish to other pharmacies)
                       // - Transition: rejected → pending (re-open for new responders)
                       (isExchangeRequester(resource.data) &&
                        isPharmacist() &&
                        exchangeImmutableFieldsUnchanged() &&
                        (
                          // Can update draft without status change
                          (resource.data.status == 'draft' && request.resource.data.status == 'draft') ||
                          // Can publish: draft → pending
                          (resource.data.status == 'draft' && request.resource.data.status == 'pending') ||
                          // Can re-open: rejected → pending
                          (resource.data.status == 'rejected' && request.resource.data.status == 'pending')
                        )) ||

                       // REQUESTER can accept/reject a proposal:
                       // - Only when proposedTo is already set (proposal received)
                       // - Transition: pending → accepted (accept the proposal)
                       // - Transition: pending → rejected (reject the proposal)
                       // - Must preserve immutable fields including proposedTo
                       (isExchangeRequester(resource.data) &&
                        isPharmacist() &&
                        resource.data.status == 'pending' &&
                        // A proposal must exist (proposedTo is set)
                        resource.data.proposedTo != null &&
                        resource.data.proposedTo != '' &&
                        exchangeImmutableFieldsUnchanged() &&
                        // Cannot change proposedTo when accepting/rejecting
                        request.resource.data.proposedTo == resource.data.proposedTo &&
                        request.resource.data.status in ['accepted', 'rejected']) ||

                       // RESPONDER can submit a proposal:
                       // - Set proposedTo to themselves (claiming the exchange)
                       // - Add offeredMedicines
                       // - Status remains pending until requester accepts
                       // - Must preserve immutable fields
                       // - CANNOT be the requester (no self-proposal)
                       (isPharmacist() &&
                        resource.data.status == 'pending' &&
                        exchangeImmutableFieldsUnchanged() &&
                        // Cannot propose on own exchange
                        resource.data.proposedBy != request.auth.uid &&
                        // Status must stay pending (requester decides)
                        request.resource.data.status == 'pending' &&
                        // Responder sets themselves as proposedTo
                        request.resource.data.proposedTo == request.auth.uid &&
                        // proposedTo must be empty before (first proposal wins)
                        (resource.data.proposedTo == null || resource.data.proposedTo == '')) ||

                       // COURIER can:
                       // - Transition: accepted → in_transit (pickup confirmed)
                       // - Transition: in_transit → completed (delivery confirmed)
                       // - Must be the assigned courier
                       // - Must preserve immutable fields
                       (isCourier() &&
                        resource.data.courierId == request.auth.uid &&
                        exchangeImmutableFieldsUnchanged() &&
                        isValidExchangeTransition(resource.data.status, request.resource.data.status) &&
                        request.resource.data.status in ['in_transit', 'completed']) ||

                       // ADMIN can update any exchange (for support/fixes)
                       // NOTE: Admin is the only role that CAN change immutable fields if needed
                       isAdmin()
                     );

      // DELETE RULES:
      // - Only requester can delete their own draft exchanges
      // - Admins can delete any exchange
      allow delete: if (isPharmacist() &&
                        isExchangeRequester(resource.data) &&
                        resource.data.status == 'draft') ||
                       isAdmin();
    }

    // ============================================
    // EXCHANGE PROPOSALS
    // ============================================

    match /exchange_proposals/{proposalId} {
      // Read the parent exchange to verify access
      function getParentExchange() {
        return get(/databases/$(database)/documents/exchanges/$(resource.data.exchangeId));
      }

      // Get parent exchange for create (uses request data since resource doesn't exist yet)
      function getParentExchangeForCreate() {
        return get(/databases/$(database)/documents/exchanges/$(request.resource.data.exchangeId));
      }

      // Helper to check if user can access proposals for an exchange
      // For broadcast exchanges (proposedTo empty), allow same-city pharmacists to read
      function canAccessExchangeProposals() {
        let exchange = getParentExchange();
        // Original requester can always read
        return exchange.data.proposedBy == request.auth.uid ||
               // Named responder can read
               exchange.data.proposedTo == request.auth.uid ||
               // Proposal author can read their own
               resource.data.proposedBy == request.auth.uid ||
               // For broadcast exchanges: same-city pharmacists can read while pending
               (isPharmacist() &&
                exchange.data.status == 'pending' &&
                (exchange.data.proposedTo == null || exchange.data.proposedTo == '') &&
                exchange.data.location != null &&
                exchange.data.location.cityId == getPharmacyCityId());
      }

      // Both parties involved in the exchange can read proposals
      // For broadcast exchanges, same-city pharmacists can also read
      allow read: if isAuthenticated() && (
                     canAccessExchangeProposals() ||
                     isAdmin()
                   );

      // CREATE RULES for proposals:
      // - Must be a pharmacist
      // - Must be the proposal author
      // - Must reference a valid, pending exchange
      // - Exchange must be in the same city as the proposer
      // - Cannot create proposal for own exchange (can't propose to yourself)
      allow create: if isPharmacist() &&
                       request.resource.data.proposedBy == request.auth.uid &&
                       request.resource.data.status == 'pending' &&
                       // Must reference a valid exchange
                       request.resource.data.exchangeId != null &&
                       // Verify the exchange exists and is pending
                       getParentExchangeForCreate().data.status == 'pending' &&
                       // Cannot create proposal for your own exchange
                       getParentExchangeForCreate().data.proposedBy != request.auth.uid &&
                       // Exchange must be in the proposer's city
                       getParentExchangeForCreate().data.location != null &&
                       getParentExchangeForCreate().data.location.cityId == getPharmacyCityId();

      // Only parties can update proposal status
      // Exchange requester (to accept/reject) or proposal author (to withdraw)
      allow update: if isAuthenticated() && (
                       getParentExchange().data.proposedBy == request.auth.uid ||
                       resource.data.proposedBy == request.auth.uid
                     );

      // Only proposal author can delete their proposal
      allow delete: if isPharmacist() &&
                       resource.data.proposedBy == request.auth.uid;
    }

    // ============================================
    // ADMIN LOCATION MANAGEMENT
    // ============================================

    // Countries - Admin managed
    match /countries/{countryId} {
      // All authenticated users can read countries
      allow read: if isAuthenticated();
      // Only admins can create, update, delete
      allow create, update, delete: if isAdmin();
    }

    // Cities - Admin managed
    match /cities/{cityId} {
      // All authenticated users can read cities
      allow read: if isAuthenticated();
      // Only admins can create, update, delete
      allow create, update, delete: if isAdmin();
    }

    // Courier Assignments - Admin managed
    match /courier_assignments/{assignmentId} {
      // Admins and the assigned courier can read
      allow read: if isAdmin() ||
                     (isCourier() && resource.data.courierId == request.auth.uid);
      // Only admins can create, update, delete
      allow create, update, delete: if isAdmin();
    }

    // ============================================
    // WALLET & FINANCIAL COLLECTIONS
    // ============================================
    // NOTE: App uses 'wallets' and 'ledger' collections (wallet-firebase.service.ts)
    // NOT 'transactions' or 'payouts' - those are handled via ledger and courier_payouts

    // Wallets - Users can read and manage their own wallet
    match /wallets/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      // Users can create their own wallet
      allow create: if isOwner(userId) &&
                       request.resource.data.balance >= 0;
      // Users can update their wallet (for top-ups, payments)
      // Balance cannot go negative
      allow update: if (isOwner(userId) && request.resource.data.balance >= 0) ||
                       isAdmin();
      allow delete: if isAdmin();
    }

    // Ledger - Transaction history for wallets
    // Users can read their own transactions via queries
    match /ledger/{transactionId} {
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid || isAdmin());
      // Allow users to create their own transaction records (for demo purposes)
      // In production, this should be Cloud Functions only
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;
      allow update, delete: if false; // Immutable - audit trail
    }

    // ============================================
    // SUBSCRIPTION COLLECTIONS
    // ============================================

    // Subscriptions - Users can read and manage their own subscriptions
    match /subscriptions/{subscriptionId} {
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid || isAdmin());
      // Allow users to create their own subscription (for demo purposes)
      // In production, this should be Cloud Functions only
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;
      // Allow users to update their own subscription status
      allow update: if (isAuthenticated() && resource.data.userId == request.auth.uid) ||
                       isAdmin();
      allow delete: if false;
    }

    // ============================================
    // DELIVERIES - With Payment Gate
    // ============================================

    match /deliveries/{deliveryId} {
      // READ RULES:
      // - Involved pharmacies can always read their deliveries
      // - Assigned courier can read their delivery
      // - CRITICAL: Couriers can ONLY see pending deliveries if:
      //   1. Payment is complete (both pharmacies paid)
      //   2. Delivery is in their operating city
      // - Admins can read all
      allow read: if isAuthenticated() && (
                     // Involved pharmacies can always read
                     resource.data.fromPharmacyId == request.auth.uid ||
                     resource.data.toPharmacyId == request.auth.uid ||
                     // Assigned courier can read
                     resource.data.courierId == request.auth.uid ||
                     // Admin can read all
                     isAdmin()
                   );

      // CRITICAL: Couriers browsing available deliveries
      // Only show deliveries where BOTH pharmacies have paid
      allow read: if isCourier() &&
                     resource.data.status == 'pending' &&
                     // PAYMENT GATE: Both pharmacies must have paid
                     isDeliveryPaymentComplete(resource.data) &&
                     // City restriction
                     resource.data.location != null &&
                     resource.data.location.cityId != null &&
                     courierOperatesInCity(resource.data.location.cityId);

      // UPDATE RULES with state machine and payment enforcement:
      allow update: if isAuthenticated() && (
                       // COURIER accepting delivery:
                       // - Can only accept if payment is complete
                       // - Must be in their operating city
                       // - Transition: pending → assigned
                       (isCourier() &&
                        resource.data.status == 'pending' &&
                        request.resource.data.status == 'assigned' &&
                        request.resource.data.courierId == request.auth.uid &&
                        // PAYMENT GATE
                        isDeliveryPaymentComplete(resource.data) &&
                        // City restriction
                        resource.data.location != null &&
                        courierOperatesInCity(resource.data.location.cityId)) ||

                       // COURIER updating assigned delivery:
                       // - Must be the assigned courier
                       // - Valid transitions only: assigned → picked_up → in_transit → delivered/failed
                       (isCourier() &&
                        resource.data.courierId == request.auth.uid &&
                        isValidDeliveryTransition(resource.data.status, request.resource.data.status) &&
                        request.resource.data.status in ['picked_up', 'in_transit', 'delivered', 'failed']) ||

                       // PHARMACY cancelling delivery:
                       // - Only before pickup (pending or assigned status)
                       // - Only involved pharmacies can cancel
                       (isPharmacist() &&
                        (resource.data.fromPharmacyId == request.auth.uid ||
                         resource.data.toPharmacyId == request.auth.uid) &&
                        resource.data.status in ['pending', 'assigned'] &&
                        request.resource.data.status == 'cancelled') ||

                       // PHARMACY updating payment fields ONLY:
                       // - Can only update their own payment record (fromPharmacyPayment or toPharmacyPayment)
                       // - Can update paymentStatus and updatedAt
                       // - Uses affectedKeys().hasOnly() to prevent modifying any other fields
                       (isPharmacist() &&
                        resource.data.status in ['pending', 'assigned'] &&
                        // From pharmacy can only update their payment fields
                        ((resource.data.fromPharmacyId == request.auth.uid &&
                          // STRICT: Only these fields can be modified
                          request.resource.data.diff(resource.data).affectedKeys()
                            .hasOnly(['fromPharmacyPayment', 'paymentStatus', 'updatedAt']) &&
                          request.resource.data.fromPharmacyPayment != null &&
                          request.resource.data.fromPharmacyPayment.status in ['pending', 'paid']) ||
                         // To pharmacy can only update their payment fields
                         (resource.data.toPharmacyId == request.auth.uid &&
                          // STRICT: Only these fields can be modified
                          request.resource.data.diff(resource.data).affectedKeys()
                            .hasOnly(['toPharmacyPayment', 'paymentStatus', 'updatedAt']) &&
                          request.resource.data.toPharmacyPayment != null &&
                          request.resource.data.toPharmacyPayment.status in ['pending', 'paid']))) ||

                       // ADMIN can update any delivery
                       isAdmin()
                     );

      // CREATE/DELETE: Only via Cloud Functions or Admin
      allow create: if isAdmin();
      allow delete: if isAdmin();
    }

    // NOTE: delivery_payments collection is NOT used by the app.
    // Payment data is stored directly in the deliveries document
    // (fromPharmacyPayment, toPharmacyPayment, paymentStatus fields).
    // See: delivery-payment-firebase.service.ts

    // Subscription Plans - Read by all, managed by admins
    match /subscription_plans/{planId} {
      // All authenticated users can read plans
      allow read: if isAuthenticated();
      // Only admins can create, update, delete plans
      allow create, update, delete: if isAdmin();
    }

    // ============================================
    // REQUEST COLLECTIONS (User creates, Admin processes)
    // ============================================

    // Top-up Requests - Users can create and read their own requests
    match /topup_requests/{requestId} {
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid || isAdmin());
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.amount > 0 &&
                       request.resource.data.status == 'pending';
      // Only admins can update request status (approve/reject)
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Withdraw Requests - Users can create and read their own requests
    match /withdraw_requests/{requestId} {
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid || isAdmin());
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.amount > 0 &&
                       request.resource.data.status == 'pending';
      // Only admins can update request status (approve/reject)
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Subscription Requests - Users can create and read their own requests
    match /subscription_requests/{requestId} {
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid || isAdmin());
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.status == 'pending';
      // Only admins can update request status (approve/reject)
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // ============================================
    // COURIER EARNINGS & PAYMENTS
    // ============================================

    // Courier Earnings - Couriers can read their own earnings
    match /courier_earnings/{earningId} {
      // Couriers can read their own earnings
      // Admins can read all for payout processing
      allow read: if isAuthenticated() &&
                     (resource.data.courierId == request.auth.uid || isAdmin());
      // Earnings are created when a courier confirms delivery
      // The courier creating must match the courierId in the earning
      // and must be in pending status with proper amounts
      allow create: if isCourier() &&
                       request.resource.data.courierId == request.auth.uid &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.amount > 0 &&
                       request.resource.data.netAmount > 0;
      // Only admins can update earning status (for payout processing)
      // Or courier's own earnings for status updates (pending -> available -> processing)
      allow update: if isAdmin() ||
                       (isCourier() &&
                        resource.data.courierId == request.auth.uid &&
                        request.resource.data.status in ['available', 'processing']);
      allow delete: if false;
    }

    // Courier Wallets - Couriers can read their own wallet
    match /courier_wallets/{courierId} {
      // Courier can read their own wallet
      allow read: if isOwner(courierId) || isAdmin();

      // Courier can create their own wallet
      // Wallet can be created with initial earnings (from first delivery)
      // or with zero balances when courier first accesses it
      allow create: if isOwner(courierId) &&
                       isCourier() &&
                       request.resource.data.courierId == courierId &&
                       request.resource.data.availableBalance >= 0 &&
                       request.resource.data.pendingBalance >= 0 &&
                       request.resource.data.totalEarned >= 0 &&
                       request.resource.data.totalWithdrawn == 0;

      // Couriers can update their own wallet for:
      // 1. Payment preferences (always allowed)
      // 2. Balance updates (pendingBalance, availableBalance, totalEarned)
      //    - pendingBalance can increase (new earnings) or decrease (moved to available)
      //    - availableBalance can increase (from pending) or decrease (payout requested)
      //    - totalEarned can only increase
      // Note: For production, balance updates should ideally be handled by Cloud Functions
      allow update: if isOwner(courierId) &&
                       isCourier() &&
                       request.resource.data.courierId == courierId &&
                       // Ensure totalWithdrawn doesn't decrease (prevents fraud)
                       request.resource.data.totalWithdrawn >= resource.data.totalWithdrawn &&
                       // Ensure balances don't go negative
                       request.resource.data.availableBalance >= 0 &&
                       request.resource.data.pendingBalance >= 0;

      // Admins can update wallet balances (for payouts, earnings processing)
      allow update: if isAdmin();

      allow delete: if false;
    }

    // Courier Payouts - Couriers can read and request payouts
    match /courier_payouts/{payoutId} {
      // Courier can read their own payouts
      // Admins can read all for processing
      allow read: if isAuthenticated() &&
                     (resource.data.courierId == request.auth.uid || isAdmin());
      // Couriers can create payout requests
      allow create: if isCourier() &&
                       request.resource.data.courierId == request.auth.uid &&
                       request.resource.data.amount > 0 &&
                       request.resource.data.status == 'pending';
      // Only admins can update payout status (approve/reject)
      allow update: if isAdmin();
      allow delete: if false;
    }

    // Delivery Fee Configs - Admin managed
    match /delivery_fee_configs/{configId} {
      // All authenticated users can read fee configs
      allow read: if isAuthenticated();
      // Only admins can manage fee configurations
      allow create, update, delete: if isAdmin();
    }

    // ============================================
    // AUDIT LOGS
    // ============================================

    // Audit logs are immutable - can only be created, never updated or deleted
    match /audit_logs/{logId} {
      // Only admins can read audit logs
      allow read: if isAdmin();
      // Authenticated users can create audit logs for their own actions
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.timestamp != null;
      // No updates or deletes allowed - audit logs are immutable
      allow update, delete: if false;
    }

    // ============================================
    // DENY ALL OTHER ACCESS
    // ============================================

    // Catch-all rule - deny access to any undefined collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
